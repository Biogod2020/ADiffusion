<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>夜间模式代码审阅文档</title>
  <!-- 引入 PrismJS 夜间模式主题 -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <style>
    /* 全局样式设置 */
    body {
      background-color: #282c34;
      color: #abb2bf;
      font-family: 'Fira Code', Consolas, 'Courier New', monospace;
      line-height: 1.6;
      margin: 0;
      padding: 2rem;
    }
    header, footer {
      text-align: center;
      margin-bottom: 2rem;
    }
    h1, h2, h3, h4 {
      color: #61dafb;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }
    p, li {
      font-size: 1rem;
    }
    a {
      color: #61dafb;
    }
    /* 代码块样式 */
    pre {
      background: #1e2127;
      padding: 1rem;
      overflow-x: auto;
      border-radius: 5px;
      margin-bottom: 1.5rem;
    }
    code {
      font-size: 0.95rem;
    }
    /* 分区样式 */
    .section {
      margin-bottom: 3rem;
    }
    /* 目录样式 */
    .toc {
      margin-bottom: 2rem;
    }
    .toc h2 {
      margin-bottom: 1rem;
    }
    .toc ul {
      list-style-type: none;
      padding-left: 1rem;
    }
    .toc ul ul {
      padding-left: 1rem;
    }
    .toc a {
      text-decoration: none;
      color: #abb2bf;
      display: block;
      padding: 0.2rem 0;
    }
    .toc a:hover {
      color: #61dafb;
    }

    @media (max-width: 768px) {
      body { padding: 1rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>夜间模式代码审阅文档</h1>
    <p>本页面将代码分为多个模块，每个模块的功能说明均以 HTML 文本形式呈现，方便你对代码整体进行审阅和理解。</p>
  </header>

  <div class="toc">
    <h2>目录</h2>
    <ul>
      <li><a href="#section1">1. 文件与目录操作</a>
        <ul>
          <li><a href="#section1-1">1.1. 列出目录内容</a></li>
          <li><a href="#section1-2">1.2. 检查目录是否存在</a></li>
          <li><a href="#section1-3">1.3. 初始化路径变量</a></li>
          <li><a href="#section1-4">1.4. 统计文件夹文件数量</a></li>
        </ul>
      </li>
      <li><a href="#section2">2. 构建原始图像数据字典</a>
        <ul>
          <li><a href="#section2-1">2.1. 定义原始数据路径</a></li>
          <li><a href="#section2-2">2.2. <code>raw_get_key</code> 函数</a></li>
          <li><a href="#section2-3">2.3. 初始化字典</a></li>
          <li><a href="#section2-4">2.4. 遍历目录构建字典</a>
            <ul>
              <li><a href="#section2-4-1">2.4.1. 处理文件</a></li>
              <li><a href="#section2-4-2">2.4.2. 处理文件夹</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#section3">3. 构建目标文件映射及最终映射关系</a>
        <ul>
          <li><a href="#section3-1">3.1. 构建目标文件映射</a></li>
          <li><a href="#section3-2">3.2. 初始化最终映射字典</a></li>
          <li><a href="#section3-3">3.3. 生成基础映射关系</a></li>
          <li><a href="#section3-4">3.4. 手动指定特殊映射</a></li>
          <li><a href="#section3-5">3.5. 输出映射关系及检查</a></li>
        </ul>
      </li>
      <li><a href="#section4">4. 利用 SIFT 进行图像对齐</a>
        <ul>
          <li><a href="#section4-1">4.1. 设置对齐输出文件夹</a></li>
          <li><a href="#section4-2">4.2. <code>get_sift_detector</code> 函数</a></li>
          <li><a href="#section4-3">4.3. <code>align_images_flexible</code> 函数</a>
            <ul>
              <li><a href="#section4-3-1">4.3.1. 读取图像</a></li>
              <li><a href="#section4-3-2">4.3.2. 选择 SIFT 检测器</a></li>
              <li><a href="#section4-3-3">4.3.3. 特征检测与匹配</a></li>
              <li><a href="#section4-3-4">4.3.4. 单应性矩阵计算</a></li>
              <li><a href="#section4-3-5">4.3.5. 图像对齐与保存</a></li>
              <li><a href="#section4-3-6">4.3.6. 生成对比图</a></li>
            </ul>
          </li>
          <li><a href="#section4-4">4.4. 设置对比图输出文件夹</a></li>
          <li><a href="#section4-5">4.5. 批量图像对齐处理</a>
            <ul>
              <li><a href="#section4-5-1">4.5.1. 第一次循环：处理一般情况</a></li>
              <li><a href="#section4-5-2">4.5.2. 第二次循环：处理特殊 Key</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#section5">5. 分析对齐图像并生成 CSV</a>
        <ul>
          <li><a href="#section5-1">5.1. <code>process_aligned_image</code> 函数</a>
            <ul>
              <li><a href="#section5-1-1">5.1.1. 读取图像和通道分离</a></li>
              <li><a href="#section5-1-2">5.1.2. 创建彩色区域掩膜</a></li>
              <li><a href="#section5-1-3">5.1.3. 连通组件分析</a></li>
              <li><a href="#section5-1-4">5.1.4. 结果整理</a></li>
            </ul>
          </li>
          <li><a href="#section5-2">5.2. <code>generate_csv</code> 函数</a>
            <ul>
              <li><a href="#section5-2-1">5.2.1. 循环处理对齐图像</a></li>
              <li><a href="#section5-2-2">5.2.2. CSV 文件写入</a></li>
            </ul>
          </li>
          <li><a href="#section5-3">5.3. 执行分析并生成 CSV</a></li>
        </ul>
      </li>
      <li><a href="#section6">6. 生成绿色叠加图与三联对比图</a>
        <ul>
          <li><a href="#section6-1">6.1. 创建对齐图像基础路径映射</a></li>
          <li><a href="#section6-2">6.2. 构建完整映射字典 <code>allmap</code></a></li>
          <li><a href="#section6-3">6.3. 定义输出路径</a></li>
          <li><a href="#section6-4">6.4. <code>load_plaque_data</code> 函数</a></li>
          <li><a href="#section6-5">6.5. <code>create_green_overlay</code> 函数</a></li>
          <li><a href="#section6-6">6.6. <code>create_black_bg_with_circles</code> 函数</a></li>
          <li><a href="#section6-7">6.7. <code>create_3panel_comparison</code> 函数</a></li>
          <li><a href="#section6-8">6.8. 加载斑块数据</a></li>
          <li><a href="#section6-9">6.9. 批量生成图像</a></li>
        </ul>
      </li>
    </ul>
  </div>

  <!-- 模块1：文件与目录操作 -->
  <section class="section" id="section1">
    <h2>1. 文件与目录操作</h2>

    <section id="section1-1">
      <h3>1.1. 列出目录内容</h3>
      <p>
        这段代码使用 <code>os.listdir()</code> 列出指定目录 <code>/cwStorage/nodecw_group</code> 的内容，用于快速查看该目录下的文件和文件夹。
      </p>
      <pre><code class="language-python">
# 文件与目录操作
directory_all = "/cwStorage/nodecw_group"
print("nodecw_group目录内容：", os.listdir(directory_all))
      </code></pre>
    </section>

    <section id="section1-2">
      <h3>1.2. 检查目录是否存在</h3>
      <p>
        使用 <code>os.path.exists()</code> 检查当前目录下是否存在 <code>./plaque_napari_circled</code> 目录，这通常用于验证后续操作的目录前提条件是否满足。
      </p>
      <pre><code class="language-python">
print("是否存在'./plaque_napari_circled'目录？", os.path.exists("./plaque_napari_circled"))
      </code></pre>
    </section>

    <section id="section1-3">
      <h3>1.3. 列出 zhchen 目录内容</h3>
      <p>
        同样使用 <code>os.listdir()</code>，这次是列出用户 <code>zhchen</code> 的个人目录内容，以便了解目标处理数据可能存放的位置。
      </p>
      <pre><code class="language-python">
print("zhchen目录内容：", os.listdir("/cwStorage/nodecw_group/zhchen/"))
      </code></pre>
    </section>

    <section id="section1-4">
      <h3>1.4. 初始化路径变量</h3>
      <p>
        定义了 <code>origin_path</code> 和 <code>destination_path</code> 变量，分别指向原始数据目录和目标数据目录。这些路径在后续的文件操作中会被多次使用。
      </p>
      <pre><code class="language-python">
origin_path = "./plaque_napari_circled"
destination_path = "/cwStorage/nodecw_group/zhchen/plaque_napari_circled"
      </code></pre>
    </section>

    <section id="section1-5">
      <h3>1.5. 统计文件夹文件数量</h3>
      <p>
        通过 <code>os.listdir()</code> 获取目标文件夹和 <code>stereo_img</code> 文件夹的文件列表，并使用 <code>len()</code> 函数统计文件数量。这有助于快速了解文件夹的文件规模。
      </p>
      <pre><code class="language-python">
dest_files = os.listdir(destination_path)
print("目标文件夹文件数：", len(dest_files))
stereo_img_path = "/cwStorage/nodecw_group/jijh/stereo_img"
print("stereo_img文件夹文件数：", len(os.listdir(stereo_img_path)))
print("stereo_img文件夹内容：", os.listdir(stereo_img_path))
      </code></pre>
    </section>
  </section>

  <!-- 模块2：构建原始图像数据字典 -->
  <section class="section" id="section2">
    <h2>2. 构建原始图像数据字典</h2>
    <p>
      本模块旨在解析原始图像文件名，并根据文件名中的 "plaque" 和 "dapi" 关键词，分别构建 <code>plaque_raw</code> 和 <code>dapi_raw</code> 两个字典。字典的键值是图像文件名的前缀（大写），值是包含该前缀的所有图像文件路径列表。
    </p>

    <section id="section2-1">
      <h3>2.1. 定义原始数据路径</h3>
      <p>
        设置变量 <code>raw_path</code> 指向原始图像数据所在的目录 <code>/cwStorage/nodecw_group/jijh/stereo_img</code>。
      </p>
      <pre><code class="language-python">
# 构建原始图像数据字典
raw_path = "/cwStorage/nodecw_group/jijh/stereo_img"
      </code></pre>
    </section>

    <section id="section2-2">
      <h3>2.2. <code>raw_get_key</code> 函数</h3>
      <p>
        定义函数 <code>raw_get_key(tif_filename: str) -> str</code>，该函数接收一个 tif 文件名作为输入，通过文件名中的第一个连字符 <code>-</code> 分割文件名，提取前缀，并将前缀转换为大写字母后返回。这个函数用于从文件名中提取字典的键。
      </p>
      <pre><code class="language-python">
def raw_get_key(tif_filename: str) -> str:
    prefix = tif_filename.split('-', 1)[0]
    return prefix.upper()
      </code></pre>
    </section>

    <section id="section2-3">
      <h3>2.3. 初始化字典</h3>
      <p>
        初始化两个空字典 <code>plaque_raw</code> 和 <code>dapi_raw</code>，用于分别存储包含 "plaque" 和 "dapi" 关键词的图像文件路径。
      </p>
      <pre><code class="language-python">
plaque_raw = {}
dapi_raw = {}
      </code></pre>
    </section>

    <section id="section2-4">
      <h3>2.4. 遍历目录构建字典</h3>
      <p>
        遍历 <code>raw_path</code> 目录下的所有条目（文件和文件夹），根据条目的类型和文件名（或文件夹名）中的关键词，将图像文件路径添加到相应的字典中。
      </p>
      <pre><code class="language-python">
for entry in os.listdir(raw_path):
    entry_path = os.path.join(raw_path, entry)
    if os.path.isfile(entry_path) and entry.lower().endswith('.tif'):
        # ... (处理文件)
    elif os.path.isdir(entry_path):
        # ... (处理文件夹)
    </code></pre>

      <section id="section2-4-1">
        <h4>2.4.1. 处理文件</h4>
        <p>
          如果当前条目是文件，并且文件名以 ".tif" 结尾（忽略大小写），则检查文件名是否包含 "plaque" 或 "dapi" 关键词（忽略大小写）。如果包含 "plaque"，则调用 <code>raw_get_key()</code> 函数获取键，并将文件路径添加到 <code>plaque_raw</code> 字典中；如果包含 "dapi"，则添加到 <code>dapi_raw</code> 字典中。<code>setdefault</code> 方法用于初始化字典中键对应的值为空列表，如果键不存在的话。
        </p>
        <pre><code class="language-python">
        if os.path.isfile(entry_path) and entry.lower().endswith('.tif'):
            if 'plaque' in entry.lower():
                key = raw_get_key(entry)
                plaque_raw.setdefault(key, []).append(entry_path)
            if 'dapi' in entry.lower():
                key = raw_get_key(entry)
                dapi_raw.setdefault(key, []).append(entry_path)
        </code></pre>
      </section>

      <section id="section2-4-2">
        <h4>2.4.2. 处理文件夹</h4>
        <p>
          如果当前条目是文件夹，则检查文件夹名是否包含 "plaque"、"tritic" 或 "dapi" 关键词（忽略大小写）。如果包含 "plaque" 或 "tritic"，则遍历该文件夹下的所有文件，找到以 ".tif" 结尾的文件，并根据文件名或文件夹名使用 <code>raw_get_key()</code> 获取键，将文件路径添加到 <code>plaque_raw</code> 字典中。对于包含 "dapi" 的文件夹，执行类似的操作，将文件路径添加到 <code>dapi_raw</code> 字典中。这里逻辑稍微复杂，需要注意键的生成方式，以及对文件夹和文件名的双重检查。
        </p>
        <pre><code class="language-python">
    elif os.path.isdir(entry_path):
        folder_lower = entry.lower()
        if "plaque" in folder_lower or "tritic" in folder_lower:
            for sub_file in os.listdir(entry_path):
                sub_path = os.path.join(entry_path, sub_file)
                if os.path.isfile(sub_path) and sub_file.lower().endswith(".tif"):
                    if raw_get_key(sub_file) != raw_get_key(entry):
                        key = raw_get_key(entry)
                        plaque_raw.setdefault(key, []).append(sub_path)
                    else:
                        key = raw_get_key(sub_file)
                        plaque_raw.setdefault(key, []).append(sub_path)
        elif "dapi" in folder_lower:
            for sub_file in os.listdir(entry_path):
                sub_path = os.path.join(entry_path, sub_file)
                if os.path.isfile(sub_path) and sub_file.lower().endswith('.tif'):
                    if raw_get_key(sub_file) != raw_get_key(entry):
                        key = raw_get_key(entry)
                        dapi_raw.setdefault(key, []).append(sub_path)
                    else:
                        key = raw_get_key(sub_file)
                        dapi_raw.setdefault(key, []).append(sub_path)
        </code></pre>
      </section>
    </section>
  </section>

  <!-- 模块3：构建目标文件映射及最终映射关系 -->
  <section class="section" id="section3">
    <h2>3. 构建目标文件映射及最终映射关系</h2>
    <p>
      本模块的目标是建立原始图像文件与目标文件夹中文件的映射关系，最终生成 <code>final_mapping</code> 字典。这个字典将用于后续的图像对齐操作，确保原始图像与处理后的图像能够正确配对。
    </p>

    <section id="section3-1">
      <h3>3.1. 构建目标文件映射</h3>
      <p>
        首先，获取目标文件夹 <code>destination_path</code> 中的所有文件名，并构建一个名为 <code>dest_map</code> 的字典。这个字典的键是文件名（不包含扩展名），值是完整的文件名（包含扩展名）。这为后续通过文件名快速查找目标文件提供了方便。
      </p>
      <pre><code class="language-python">
# 构建目标文件映射及最终映射关系
dest_files = os.listdir(destination_path)
dest_map = {os.path.splitext(f)[0]: f for f in dest_files}
      </code></pre>
    </section>

    <section id="section3-2">
      <h3>3.2. 初始化最终映射字典</h3>
      <p>
        初始化一个空字典 <code>final_mapping</code>，用于存储最终的映射关系。这个字典的键将是图像文件的前缀，值是一个包含 <code>src</code>（源文件路径列表）和 <code>dest</code>（目标文件路径）的字典。
      </p>
      <pre><code class="language-python">
final_mapping = {}
      </code></pre>
    </section>

    <section id="section3-3">
      <h3>3.3. 生成基础映射关系</h3>
      <p>
        遍历之前构建的 <code>plaque_raw</code> 字典。对于 <code>plaque_raw</code> 中的每个键值对（键是图像前缀，值是源文件路径列表），如果源文件路径列表中只有一个文件路径，并且该键也存在于 <code>dest_map</code> 字典的键集合中，则认为找到了一个基础的映射关系。将这个映射关系添加到 <code>final_mapping</code> 字典中。
      </p>
      <pre><code class="language-python">
for key, source_paths in plaque_raw.items():
    if len(source_paths) == 1 and key in dest_map.keys():
        final_mapping[key] = {
            "src": source_paths,
            "dest": os.path.join(destination_path, dest_map[key]),
        }
      </code></pre>
    </section>

    <section id="section3-4">
      <h3>3.4. 手动指定特殊映射</h3>
      <p>
        对于某些特殊情况，例如 "HZ4MP102" 和 "HZ4MP202" 这两个键，可能需要手动指定映射关系。这段代码直接为这两个键在 <code>final_mapping</code> 字典中设置了 <code>src</code> 和 <code>dest</code> 字段，覆盖了之前可能自动生成的映射或添加了新的映射。这里指定了 <code>plaque_raw["HZ4M02"][1]</code> 和 <code>plaque_raw["HZ4M02"][0]</code> 作为源文件，需要注意索引 <code>[1]</code> 和 <code>[0]</code> 的具体含义，可能表示 <code>plaque_raw["HZ4M02"]</code> 列表中文件路径的顺序。
      </p>
      <pre><code class="language-python">
final_mapping["HZ4MP102"] = {
    "src": plaque_raw["HZ4M02"][1],
    "dest": os.path.join(destination_path, dest_map["HZ4MP102"])
}
final_mapping["HZ4MP202"] = {
    "src": plaque_raw["HZ4M02"][0],
    "dest": os.path.join(destination_path, dest_map["HZ4MP202"])
}
      </code></pre>
    </section>

    <section id="section3-5">
      <h3>3.5. 输出映射关系及检查</h3>
      <p>
        最后，打印输出 <code>final_mapping</code> 字典的内容，以便检查生成的映射关系是否正确。同时，通过集合运算，分别找出 <code>plaque_raw</code> 中存在但 <code>final_mapping</code> 中缺失的键，以及 <code>dest_map</code> 中存在但 <code>final_mapping</code> 中缺失的键。这些信息可以帮助开发者快速发现映射关系中可能存在的问题。
      </p>
      <pre><code class="language-python">
print("最终映射关系：", final_mapping)
print("plaque_raw中缺失的key：", set(plaque_raw.keys()) - set(final_mapping.keys()))
print("目标文件中找不到原文件的key：", set(dest_map.keys()) - set(final_mapping.keys()))
      </code></pre>
    </section>
  </section>

  <!-- 模块4：利用 SIFT 进行图像对齐 -->
  <section class="section" id="section4">
    <h2>4. 利用 SIFT 进行图像对齐</h2>
    <p>
      本模块实现了图像对齐的功能，核心是使用 SIFT (Scale-Invariant Feature Transform) 算法检测图像特征点，并通过特征匹配和 RANSAC (RANdom SAmple Consensus) 算法估计单应性矩阵，最终将处理后的图像对齐到原始图像的坐标空间。代码优先尝试使用 GPU 加速的 SIFT，如果 GPU SIFT 不可用，则回退到 CPU 版本的 SIFT。
    </p>

    <section id="section4-1">
      <h3>4.1. 设置对齐输出文件夹</h3>
      <p>
        首先，定义对齐后图像的输出文件夹 <code>align_folder</code> 为 <code>/cwStorage/nodecw_group/zhchen/plaque_align</code>，并使用 <code>os.makedirs(align_folder, exist_ok=True)</code> 创建该文件夹。<code>exist_ok=True</code> 参数确保了如果文件夹已存在，不会抛出异常。
      </p>
      <pre><code class="language-python">
# 图像对齐：利用 SIFT 特征检测和匹配
align_folder = "/cwStorage/nodecw_group/zhchen/plaque_align"
os.makedirs(align_folder, exist_ok=True)
      </code></pre>
    </section>

    <section id="section4-2">
      <h3>4.2. <code>get_sift_detector</code> 函数</h3>
      <p>
        定义函数 <code>get_sift_detector()</code>，用于获取 SIFT 特征检测器。函数尝试创建 CUDA 加速的 SIFT 检测器 <code>cv2.cuda_SIFT_create()</code>。如果 CUDA SIFT 创建成功，则返回 SIFT 检测器对象和 <code>True</code>，表示使用了 CUDA SIFT。如果创建失败（例如，OpenCV 没有 CUDA 支持，或者 GPU 不可用），则捕获异常，打印警告信息，并创建 CPU 版本的 SIFT 检测器 <code>cv2.SIFT_create()</code>，返回 CPU SIFT 检测器对象和 <code>False</code>。
      </p>
      <pre><code class="language-python">
def get_sift_detector():
    try:
        sift = cv2.cuda_SIFT_create()
        return sift, True
    except Exception as e:
        print("[WARNING] CUDA SIFT不可用，使用CPU SIFT。")
        sift_cpu = cv2.SIFT_create()
        return sift_cpu, False
      </code></pre>
    </section>

    <section id="section4-3">
      <h3>4.3. <code>align_images_flexible</code> 函数</h3>
      <p>
        定义核心的图像对齐函数 <code>align_images_flexible(original_path, processed_path, output_path, plot_folder)</code>。该函数接收原始图像路径 <code>original_path</code>，处理后的图像路径 <code>processed_path</code>，对齐后图像的输出路径 <code>output_path</code>，以及对比图的输出文件夹 <code>plot_folder</code> 作为输入。
      </p>
      <pre><code class="language-python">
def align_images_flexible(original_path, processed_path, output_path, plot_folder):
    # ... 函数体
    </code></pre>

      <section id="section4-3-1">
        <h4>4.3.1. 读取图像</h4>
        <p>
          函数首先使用 <code>cv2.imread()</code> 读取原始图像和处理后的图像。原始图像以灰度模式读取 (<code>cv2.IMREAD_GRAYSCALE</code>)，处理后的图像以彩色模式读取 (<code>cv2.IMREAD_COLOR</code>)。如果读取失败，会抛出 <code>IOError</code> 异常。处理后的彩色图像会被转换为灰度图像，用于 SIFT 特征检测。
        </p>
        <pre><code class="language-python">
    img_original_gray = cv2.imread(original_path, cv2.IMREAD_GRAYSCALE)
    if img_original_gray is None:
        raise IOError(f"无法读取原始图像: {original_path}")
    img_processed_color = cv2.imread(processed_path, cv2.IMREAD_COLOR)
    if img_processed_color is None:
        raise IOError(f"无法读取处理后的图像: {processed_path}")
    img_processed_gray = cv2.cvtColor(img_processed_color, cv2.COLOR_BGR2GRAY)
        </code></pre>
      </section>

      <section id="section4-3-2">
        <h4>4.3.2. 选择 SIFT 检测器</h4>
        <p>
          调用之前定义的 <code>get_sift_detector()</code> 函数获取 SIFT 检测器对象 <code>sift</code> 和一个布尔值 <code>use_cuda</code>，指示是否使用了 CUDA SIFT。
        </p>
        <pre><code class="language-python">
    sift, use_cuda = get_sift_detector()
        </code></pre>
      </section>

      <section id="section4-3-3">
        <h4>4.3.3. 特征检测与匹配</h4>
        <p>
          根据 <code>use_cuda</code> 的值，选择使用 CUDA SIFT 或 CPU SIFT 进行特征检测和描述符计算。对于 CUDA SIFT，图像数据需要先上传到 GPU 内存 (<code>cv2.cuda_GpuMat()</code>, <code>upload()</code>)，然后调用 <code>sift.detectAndComputeAsync()</code> 异步进行检测和计算。对于 CPU SIFT，直接调用 <code>sift.detectAndCompute()</code>。如果 CPU SIFT 检测描述符失败 (返回 <code>None</code>)，则抛出 <code>ValueError</code> 异常。
        </p>
        <p>
          特征匹配使用暴力匹配器 (<code>cv2.BFMatcher</code> 或 <code>cv2.cuda.DescriptorMatcher_createBFMatcher</code>)，并使用 KNN (K-Nearest Neighbors) 算法找到每个特征点的前 2 个最近邻匹配点 (<code>k=2</code>)。通过 Lowe's ratio test (比例测试) 筛选好的匹配点，比例阈值设置为 0.75。
        </p>
        <pre><code class="language-python">
    if use_cuda:
        gpu_original = cv2.cuda_GpuMat()
        gpu_original.upload(img_original_gray)
        gpu_processed = cv2.cuda_GpuMat()
        gpu_processed.upload(img_processed_gray)
        kp1, des1 = sift.detectAndComputeAsync(gpu_original, None)
        kp2, des2 = sift.detectAndComputeAsync(gpu_processed, None)
        matcher = cv2.cuda.DescriptorMatcher_createBFMatcher(cv2.NORM_L2)
        knn_matches = matcher.knnMatch(des1, des2, k=2)
        ratio_thresh = 0.75
        good_matches = [m for m, n in knn_matches if m.distance < ratio_thresh * n.distance]
    else:
        kp1, des1 = sift.detectAndCompute(img_original_gray, None)
        kp2, des2 = sift.detectAndCompute(img_processed_gray, None)
        if des1 is None or des2 is None:
            raise ValueError("在CPU模式下未能检测到描述子，请检查图像。")
        bf = cv2.BFMatcher(cv2.NORM_L2, crossCheck=False)
        knn_matches = bf.knnMatch(des1, des2, k=2)
        ratio_thresh = 0.75
        good_matches = [m for m, n in knn_matches if m.distance < ratio_thresh * n.distance]
        </code></pre>
      </section>

      <section id="section4-3-4">
        <h4>4.3.4. 单应性矩阵计算</h4>
        <p>
          如果好的匹配点数量少于 4 个，则认为匹配点不足，无法计算单应性矩阵，抛出 <code>ValueError</code> 异常。否则，从好的匹配点中提取源图像和目标图像上的对应点坐标，使用 <code>cv2.findHomography()</code> 函数，结合 RANSAC 算法 (<code>cv2.RANSAC</code>) 估计单应性矩阵 <code>M</code>。RANSAC 的重投影误差阈值设置为 5.0 像素。如果单应性矩阵计算失败 (返回 <code>None</code>)，则抛出 <code>ValueError</code> 异常。
        </p>
        <pre><code class="language-python">
    if len(good_matches) < 4:
        raise ValueError(f"匹配点不足（{len(good_matches)}个），无法计算单应性矩阵：{original_path} vs {processed_path}")
    src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches]).reshape(-1, 1, 2)
    M, mask = cv2.findHomography(dst_pts, src_pts, cv2.RANSAC, 5.0)
    if M is None:
        raise ValueError("单应性矩阵计算失败。")
        </code></pre>
      </section>

      <section id="section4-3-5">
        <h4>4.3.5. 图像对齐与保存</h4>
        <p>
          使用计算得到的单应性矩阵 <code>M</code>，通过 <code>cv2.warpPerspective()</code> 函数将处理后的彩色图像 <code>img_processed_color</code> 变换到原始图像的坐标空间，得到对齐后的图像 <code>aligned_processed_color</code>。对齐后的图像尺寸与原始灰度图像 <code>img_original_gray</code> 保持一致。最后，使用 <code>cv2.imwrite()</code> 将对齐后的彩色图像保存到 <code>output_path</code>。
        </p>
        <pre><code class="language-python">
    h, w = img_original_gray.shape[:2]
    aligned_processed_color = cv2.warpPerspective(img_processed_color, M, (w, h))
    cv2.imwrite(output_path, aligned_processed_color)
        </code></pre>
      </section>

      <section id="section4-3-6">
        <h4>4.3.6. 生成对比图</h4>
        <p>
          为了直观地展示对齐效果，代码生成一个包含三张子图的对比图。这三张子图分别是：原始灰度图像 (转换为 RGB)、处理后的彩色图像 (RGB)、以及对齐后的彩色图像 (RGB)。使用 <code>matplotlib.pyplot</code> 库绘制子图，并设置标题。最后，将对比图保存到 <code>plot_folder</code> 下，文件名基于输出图像的文件名，并以 "_alignment.png" 结尾。同时，打印信息告知用户对齐结果和对比图的保存路径。
        </p>
        <pre><code class="language-python">
    aligned_processed_rgb = cv2.cvtColor(aligned_processed_color, cv2.COLOR_BGR2RGB)
    original_rgb = cv2.cvtColor(img_original_gray, cv2.COLOR_GRAY2RGB)
    processed_rgb = cv2.cvtColor(img_processed_color, cv2.COLOR_BGR2RGB)
    plt.figure(figsize=(15, 5))
    plt.subplot(1, 3, 1)
    plt.imshow(original_rgb)
    plt.title("Original (Gray)")
    plt.subplot(1, 3, 2)
    plt.imshow(processed_rgb)
    plt.title("Processed (Color)")
    plt.subplot(1, 3, 3)
    plt.imshow(aligned_processed_rgb)
    plt.title("Aligned to Original")
    plt.tight_layout()
    base_name = os.path.splitext(os.path.basename(output_path))[0]
    plot_path = os.path.join(plot_folder, f"{base_name}_alignment.png")
    plt.savefig(plot_path, dpi=150)
    plt.show()
    print(f"[INFO] 对齐结果已保存到: {output_path}")
    print(f"[INFO] 对齐对比图已保存到: {plot_path}")
        </code></pre>
      </section>
    </section>

    <section id="section4-4">
      <h3>4.4. 设置对比图输出文件夹</h3>
      <p>
        定义对比图的输出文件夹 <code>plot_folder</code> 为 <code>/cwStorage/nodecw_group/zhchen/plaque_align_plots</code>，并使用 <code>os.makedirs(plot_folder, exist_ok=True)</code> 创建该文件夹。
      </p>
      <pre><code class="language-python">
plot_folder = "/cwStorage/nodecw_group/zhchen/plaque_align_plots"
os.makedirs(plot_folder, exist_ok=True)
      </code></pre>
    </section>

    <section id="section4-5">
      <h3>4.5. 批量图像对齐处理</h3>
      <p>
        代码通过两个循环遍历 <code>final_mapping</code> 字典，对字典中指定的图像对进行对齐处理。
      </p>

      <section id="section4-5-1">
        <h4>4.5.1. 第一次循环：处理一般情况</h4>
        <p>
          第一个循环遍历 <code>final_mapping</code> 字典的所有键值对。对于每个键值对，从 <code>file_info</code> 字典中获取原始图像路径 <code>original_path</code>（取列表的第一个元素 <code>file_info["src"][0]</code>）和处理后的图像路径 <code>processed_path</code>。构建输出文件名 <code>output_filename</code> 为 <code>"{key}.tif"</code>，并拼接成完整的输出路径 <code>output_path</code>。打印信息告知用户当前正在对齐的图像对和输出路径。然后调用 <code>align_images_flexible()</code> 函数执行对齐操作。如果对齐过程中发生任何异常，则捕获异常并打印错误信息，但程序会继续执行后续的对齐任务。
        </p>
        <pre><code class="language-python">
for key, file_info in final_mapping.items():
    original_path = file_info["src"][0]
    processed_path = file_info["dest"]
    output_filename = f"{key}.tif"
    output_path = os.path.join(align_folder, output_filename)
    print(f"[INFO] 对齐 {key}: 原始: {original_path}, 处理: {processed_path}, 输出: {output_path}")
    try:
        align_images_flexible(original_path, processed_path, output_path, plot_folder)
    except Exception as e:
        print(f"[ERROR] 对齐 {key} 失败: {e}")
        </code></pre>
      </section>

      <section id="section4-5-2">
        <h4>4.5.2. 第二次循环：处理特殊 Key</h4>
        <p>
          第二个循环再次遍历 <code>final_mapping</code> 字典，但这次只处理键为 "HZ4MP102" 和 "HZ4MP202" 的情况。对于这两个特殊的键，直接使用 <code>file_info["src"]</code> 作为原始图像路径（注意这里没有取列表的第一个元素，可能 <code>file_info["src"]</code> 本身就是一个文件路径字符串，或者需要根据具体情况调整）。后续的处理步骤与第一个循环类似，调用 <code>align_images_flexible()</code> 函数进行对齐，并处理可能发生的异常。这部分代码可能是为了处理一些特殊的图像对，它们的原始图像路径可能与其他图像对的处理方式不同。
        </p>
        <pre><code class="language-python">
for key, file_info in final_mapping.items():
    if key in ("HZ4MP102", "HZ4MP202"):
        original_path = file_info["src"]
        processed_path = file_info["dest"]
        output_filename = f"{key}.tif"
        output_path = os.path.join(align_folder, output_filename)
        print(f"[INFO] 对齐 {key}: 原始: {original_path}, 处理: {processed_path}, 输出: {output_path}")
        align_images_flexible(original_path, processed_path, output_path, plot_folder)
        </code></pre>
      </section>
    </section>
  </section>

  <!-- 模块5：分析对齐图像并生成 CSV -->
  <section class="section" id="section5">
    <h2>5. 分析对齐图像并生成 CSV</h2>
    <p>
      本模块的功能是分析对齐后的图像，提取图像中彩色注释区域（斑块），计算每个连通组件的面积和质心，并将分析结果输出到 CSV 文件中。这为后续的斑块定量分析提供了数据基础。
    </p>

    <section id="section5-1">
      <h3>5.1. <code>process_aligned_image</code> 函数</h3>
      <p>
        定义函数 <code>process_aligned_image(img_path, tissue_start=1)</code>，用于处理单张对齐后的图像。<code>img_path</code> 是图像路径，<code>tissue_start</code> 是组织 ID 的起始值，默认为 1。函数返回一个包含分析结果的列表，每个元素是一个字典，代表一个检测到的斑块。
      </p>
      <pre><code class="language-python">
# 分析对齐图像并生成 CSV
def process_aligned_image(img_path, tissue_start=1):
    # ... 函数体
    </code></pre>

      <section id="section5-1-1">
        <h4>5.1.1. 读取图像和通道分离</h4>
        <p>
          函数首先使用 <code>cv2.imread(img_path, cv2.IMREAD_COLOR)</code> 以彩色模式读取对齐后的图像。如果读取失败，抛出 <code>IOError</code> 异常。然后，将图像的 BGR 三个通道分离出来，并转换为 <code>np.int16</code> 类型，以便进行后续的减法运算，避免溢出。
        </p>
        <pre><code class="language-python">
    basename = os.path.basename(img_path)
    mouse_name, _ = os.path.splitext(basename)
    img_bgr = cv2.imread(img_path, cv2.IMREAD_COLOR)
    if img_bgr is None:
        raise IOError(f"无法读取图像: {img_path}")
    b_channel = img_bgr[..., 0].astype(np.int16)
    g_channel = img_bgr[..., 1].astype(np.int16)
    r_channel = img_bgr[..., 2].astype(np.int16)
        </code></pre>
      </section>

      <section id="section5-1-2">
        <h4>5.1.2. 创建彩色区域掩膜</h4>
        <p>
          通过计算 B、G、R 通道之间的绝对差值，并设定阈值 25，来创建一个彩色区域的掩膜 <code>colored_mask</code>。如果像素在 B-G、B-R 或 G-R 通道之间的差值超过 25，则认为该像素是彩色注释区域的一部分。将得到的三个差值掩膜进行逻辑或运算，得到最终的彩色区域掩膜，并转换为 <code>np.uint8</code> 类型。
        </p>
        <pre><code class="language-python">
    diff_bg = np.abs(b_channel - g_channel) > 25
    diff_br = np.abs(b_channel - r_channel) > 25
    diff_gr = np.abs(g_channel - r_channel) > 25
    colored_mask = (diff_bg | diff_br | diff_gr).astype(np.uint8)
        </code></pre>
      </section>

      <section id="section5-1-3">
        <h4>5.1.3. 连通组件分析</h4>
        <p>
          使用 <code>cv2.connectedComponentsWithStats()</code> 函数对彩色区域掩膜 <code>colored_mask</code> 进行连通组件分析。<code>connectivity=8</code> 参数表示使用 8 邻域连接。函数返回连通组件的数量 <code>num_labels</code>、标签图像 <code>labels_im</code>、每个连通组件的统计信息 <code>stats</code> 和质心坐标 <code>centroids</code>。
        </p>
        <pre><code class="language-python">
    num_labels, labels_im, stats, centroids = cv2.connectedComponentsWithStats(colored_mask, connectivity=8)
        </code></pre>
      </section>

      <section id="section5-1-4">
        <h4>5.1.4. 结果整理</h4>
        <p>
          初始化一个空列表 <code>results</code> 用于存储结果。组织 ID <code>tissue_id</code> 初始化为 <code>tissue_start</code> 参数的值。遍历从 1 到 <code>num_labels-1</code> 的标签索引（索引 0 通常是背景）。对于每个标签索引，从 <code>stats</code> 中提取面积 <code>area</code>，从 <code>centroids</code> 中提取质心坐标 <code>(c_col, c_row)</code>。创建一个字典 <code>result_dict</code>，包含 'tissue'（组织 ID）、'count'（面积）、'mean_row'（质心行坐标）、'mean_col'（质心列坐标）和 'mouse'（鼠标名称，从文件名中提取）。将 <code>result_dict</code> 添加到 <code>results</code> 列表中，并将 <code>tissue_id</code> 递增。最后，函数返回 <code>results</code> 列表。
        </p>
        <pre><code class="language-python">
    results = []
    tissue_id = tissue_start
    for label_idx in range(1, num_labels):
        area = stats[label_idx, cv2.CC_STAT_AREA]
        c_col, c_row = centroids[label_idx]
        result_dict = {
            'tissue': tissue_id,
            'count': area,
            'mean_row': c_row,
            'mean_col': c_col,
            'mouse': mouse_name
        }
        results.append(result_dict)
        tissue_id += 1
    return results
        </code></pre>
      </section>
    </section>

    <section id="section5-2">
      <h3>5.2. <code>generate_csv</code> 函数</h3>
      <p>
        定义函数 <code>generate_csv(align_list, output_csv)</code>，用于批量处理对齐图像，生成 CSV 文件。<code>align_list</code> 是对齐图像路径列表，<code>output_csv</code> 是输出 CSV 文件的路径。
      </p>
      <pre><code class="language-python">
def generate_csv(align_list, output_csv):
    # ... 函数体
    </code></pre>

      <section id="section5-2-1">
        <h4>5.2.1. 循环处理对齐图像</h4>
        <p>
          函数初始化一个空列表 <code>all_results</code> 用于存储所有图像的分析结果。遍历 <code>align_list</code> 中的每个图像路径 <code>img_path</code>。对于每个图像，打印信息告知用户当前正在处理的图像。调用 <code>process_aligned_image(img_path)</code> 函数进行图像分析，并将返回的斑块数据列表 <code>cluster_data</code> 扩展到 <code>all_results</code> 列表中。如果处理过程中发生任何异常，则捕获异常并打印错误信息，但程序会继续处理后续图像。
        </p>
        <pre><code class="language-python">
    all_results = []
    for img_path in align_list:
        print(f"[INFO] 处理: {img_path}")
        try:
            cluster_data = process_aligned_image(img_path)
            all_results.extend(cluster_data)
        except Exception as e:
            print(f"[ERROR] 处理 {img_path} 失败: {e}")
        </code></pre>
      </section>

      <section id="section5-2-2">
        <h4>5.2.2. CSV 文件写入</h4>
        <p>
          定义 CSV 文件的字段名 <code>fieldnames</code>。使用 <code>csv.DictWriter</code> 创建 CSV 写入对象 <code>writer</code>，并指定字段名。写入 CSV 文件的表头 (<code>writer.writeheader()</code>)。然后，遍历 <code>all_results</code> 列表中的每一行数据 <code>row</code>，使用 <code>writer.writerow(row)</code> 将数据写入 CSV 文件。最后，打印信息告知用户 CSV 文件已保存到 <code>output_csv</code> 路径。
        </p>
        <pre><code class="language-python">
    fieldnames = ['tissue', 'count', 'mean_row', 'mean_col', 'mouse']
    with open(output_csv, mode='w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for row in all_results:
            writer.writerow(row)
    print(f"[INFO] CSV已保存到: {output_csv}")
        </code></pre>
      </section>
    </section>

    <section id="section5-3">
      <h3>5.3. 执行分析并生成 CSV</h3>
      <p>
        设置输出 CSV 文件的路径 <code>output_csv</code> 为 <code>/cwStorage/nodecw_group/zhchen/align_plaque_data.csv</code>。调用 <code>generate_csv(align_list, output_csv)</code> 函数，执行对齐图像的分析和 CSV 文件生成操作。这里 <code>align_list</code> 变量在代码片段中没有定义，需要根据实际情况补充定义，它应该是一个包含对齐后图像路径的列表。
      </p>
      <pre><code class="language-python">
output_csv = "/cwStorage/nodecw_group/zhchen/align_plaque_data.csv"
generate_csv(align_list, output_csv) # 注意: align_list 需要在代码的其他地方定义
      </code></pre>
    </section>
  </section>

  <!-- 模块 6：生成绿色叠加图与三联对比图 -->
  <section class="section" id="section6">
    <h2>6. 生成绿色叠加图与三联对比图</h2>
    <p>
      本模块的功能是根据之前生成的 CSV 数据，加载斑块信息，并基于原始图像和对齐图像，生成绿色叠加图和黑底圆圈图。绿色叠加图是在原始灰度图像上，将对齐图像中的彩色注释区域标记为绿色。黑底圆圈图是在黑色背景上，根据 CSV 数据中斑块的面积和质心，绘制绿色圆圈表示斑块位置和大小。最后，将原始图像、绿色叠加图和黑底圆圈图组合成三联对比图，方便可视化审阅分析结果。
    </p>

    <section id="section6-1">
      <h3>6.1. 创建对齐图像基础路径映射</h3>
      <p>
        首先，创建一个名为 <code>align_list_base</code> 的字典，用于存储对齐图像的基本路径映射关系。字典的键是去除文件扩展名的对齐图像文件名，值是完整的对齐图像路径。这里假设 <code>align_list</code> 变量在代码的其他地方已定义，并且包含了对齐后图像的完整路径列表。
      </p>
      <pre><code class="language-python">
# 生成绿色叠加图与三联对比图
align_list_base = {os.path.splitext(os.path.basename(i))[0]: i for i in align_list}
print("对齐图像基本路径映射：", align_list_base)
      </code></pre>
    </section>

    <section id="section6-2">
        <h3>6.2. 构建完整映射字典 <code>allmap</code></h3>
        <p>
          创建一个名为 <code>allmap</code> 的完整映射字典。这个字典以图像文件的前缀为键，值是一个字典，包含三个字段：<code>"src"</code> (原始图像路径), <code>"dest"</code> (目标图像路径), 和 <code>"align"</code> (对齐图像路径)。这些路径信息分别从 <code>final_mapping</code> 和 <code>align_list_base</code> 字典中获取，将之前步骤中生成的各种路径信息整合到一个统一的字典结构中，方便后续步骤的统一访问和处理。
        </p>
        <pre><code class="language-python">
  allmap = {}
  for key, path in align_list_base.items():
      allmap[key] = {
          "src": final_mapping[key]["src"][0],
          "dest": final_mapping[key]["dest"],
          "align": path,
      }
  print("最终映射字典(allmap)：", allmap)
        </code></pre>
  
      <section id="section6-3">
        <h3>6.3. 定义输出路径</h3>
        <p>
          定义了几个关键的输出路径变量：
          <ul>
            <li><code>CSV_PATH</code>: 设置斑块数据的 CSV 文件路径为 <code>/cwStorage/nodecw_group/zhchen/align_plaque_data.csv</code>。</li>
            <li><code>GREEN_FOLDER</code>: 设置绿色叠加图的输出文件夹为 <code>/cwStorage/nodecw_group/zhchen/plaque_green</code>。</li>
            <li><code>COMPARE_FOLDER</code>: 设置三联对比图的输出文件夹为 <code>/cwStorage/nodecw_group/zhchen/plaque_comparisons</code>。</li>
          </ul>
          在后续步骤中，这些路径将被用于加载 CSV 数据和保存生成的图像。
        </p>
        <pre><code class="language-python">
  CSV_PATH = "/cwStorage/nodecw_group/zhchen/align_plaque_data.csv"
  GREEN_FOLDER = "/cwStorage/nodecw_group/zhchen/plaque_green"
  COMPARE_FOLDER = "/cwStorage/nodecw_group/zhchen/plaque_comparisons"
        </code></pre>
  
      <section id="section6-4">
        <h3>6.4. <code>load_plaque_data</code> 函数</h3>
        <p>
          定义函数 <code>load_plaque_data(csv_path)</code>，用于从 CSV 文件中加载斑块数据。函数接收 CSV 文件路径 <code>csv_path</code> 作为输入，返回一个字典 <code>plaque_dict</code>。这个字典的键是鼠标名称，值是一个列表，列表中的每个元素是一个元组，包含斑块的面积 (count)、质心行坐标 (mean_row) 和质心列坐标 (mean_col)。
        </p>
        <pre><code class="language-python">
  def load_plaque_data(csv_path):
      plaque_dict = {}
      with open(csv_path, mode='r', encoding='utf-8') as f:
          reader = csv.DictReader(f)
          for row in reader:
              mouse = row["mouse"]
              count = float(row["count"])
              mean_row = float(row["mean_row"])
              mean_col = float(row["mean_col"])
              plaque_dict.setdefault(mouse, []).append((count, mean_row, mean_col))
      return plaque_dict
        </code></pre>
        <p>
          **代码详解:**
          <ul>
            <li><code>plaque_dict = {}</code>: 初始化一个空字典 <code>plaque_dict</code>，用于存储加载的斑块数据。</li>
            <li><code>with open(csv_path, mode='r', encoding='utf-8') as f:</code>: 打开 CSV 文件，以只读模式 (<code>'r'</code>) 打开，并指定编码为 UTF-8。使用 <code>with open</code> 语句可以确保文件在使用完毕后自动关闭。</li>
            <li><code>reader = csv.DictReader(f)</code>: 创建 <code>csv.DictReader</code> 对象 <code>reader</code>，用于按字典方式读取 CSV 文件。CSV 文件的第一行被视为字段名。</li>
            <li><code>for row in reader:</code>: 遍历 CSV 文件的每一行，<code>row</code> 是一个字典，键是字段名，值是该字段对应的值。</li>
            <li><code>mouse = row["mouse"]</code>: 从当前行字典 <code>row</code> 中获取 "mouse" 字段的值，即鼠标名称。</li>
            <li><code>count = float(row["count"])</code>, <code>mean_row = float(row["mean_row"])</code>, <code>mean_col = float(row["mean_col"])</code>: 从 <code>row</code> 中获取 "count"、"mean_row" 和 "mean_col" 字段的值，并将它们转换为浮点数类型。</li>
            <li><code>plaque_dict.setdefault(mouse, []).append((count, mean_row, mean_col))</code>: 使用 <code>setdefault</code> 方法。如果 <code>mouse</code> (鼠标名称) 已经存在于 <code>plaque_dict</code> 中，则获取对应的列表；如果不存在，则创建一个空列表并将其设置为 <code>mouse</code> 键的值。然后，将包含斑块信息的元组 <code>(count, mean_row, mean_col)</code> 添加到该列表中。这样，相同鼠标名称的斑块信息会被存储在同一个列表中。</li>
            <li><code>return plaque_dict</code>: 函数返回构建好的 <code>plaque_dict</code> 字典。</li>
          </ul>
        </p>
  
      <section id="section6-5">
        <h3>6.5. <code>create_green_overlay</code> 函数</h3>
        <p>
          定义函数 <code>create_green_overlay(src_path, align_path, output_path)</code>，用于创建绿色叠加图。函数接收原始图像路径 <code>src_path</code>, 对齐图像路径 <code>align_path</code> 和输出图像路径 <code>output_path</code> 作为输入。函数在原始灰度图像上，将对齐图像中检测到的彩色注释区域标记为绿色，并将结果保存到 <code>output_path</code>。函数返回生成的绿色叠加图 (BGR 格式)。
        </p>
        <pre><code class="language-python">
  def create_green_overlay(src_path, align_path, output_path):
      src_gray = cv2.imread(src_path, cv2.IMREAD_GRAYSCALE)
      if src_gray is None:
          raise IOError(f"无法加载原始图像: {src_path}")
      src_bgr = cv2.cvtColor(src_gray, cv2.COLOR_GRAY2BGR)
      align_bgr = cv2.imread(align_path, cv2.IMREAD_COLOR)
      if align_bgr is None:
          raise IOError(f"无法加载对齐图像: {align_path}")
      if src_bgr.shape != align_bgr.shape:
          raise ValueError("原始图与对齐图尺寸不匹配。")
      b = align_bgr[..., 0].astype(np.int16)
      g = align_bgr[..., 1].astype(np.int16)
      r = align_bgr[..., 2].astype(np.int16)
      diff_bg = np.abs(b - g) > 25
      diff_br = np.abs(b - r) > 25
      diff_gr = np.abs(g - r) > 25
      colored_mask = (diff_bg | diff_br | diff_gr)
      src_bgr[colored_mask] = [0, 255, 0]
      cv2.imwrite(output_path, src_bgr)
      return src_bgr
        </code></pre>
        <p>
          **代码详解:**
          <ul>
            <li><code>src_gray = cv2.imread(src_path, cv2.IMREAD_GRAYSCALE)</code>: 以灰度模式读取原始图像。</li>
            <li><code>if src_gray is None: raise IOError(...)</code>: 检查是否成功加载原始图像，如果失败，抛出 <code>IOError</code> 异常。</li>
            <li><code>src_bgr = cv2.cvtColor(src_gray, cv2.COLOR_GRAY2BGR)</code>: 将原始灰度图像转换为 BGR 彩色图像，以便可以进行颜色叠加。</li>
            <li><code>align_bgr = cv2.imread(align_path, cv2.IMREAD_COLOR)</code>: 以彩色模式读取对齐后的图像。</li>
            <li><code>if align_bgr is None: raise IOError(...)</code>: 检查是否成功加载对齐图像，如果失败，抛出 <code>IOError</code> 异常.</li>
            <li><code>if src_bgr.shape != align_bgr.shape: raise ValueError(...)</code>: 检查原始图像和对齐图像的尺寸是否一致，如果不一致，抛出 <code>ValueError</code> 异常。</li>
            <li><code>b = align_bgr[..., 0].astype(np.int16)</code>, <code>g = align_bgr[..., 1].astype(np.int16)</code>, <code>r = align_bgr[..., 2].astype(np.int16)</code>: 分离对齐图像的 BGR 通道，并转换为 <code>np.int16</code> 类型。</li>
            <li><code>diff_bg = np.abs(b - g) > 25</code>, <code>diff_br = np.abs(b - r) > 25</code>, <code>diff_gr = np.abs(g - r) > 25</code>: 计算 B-G, B-R, G-R 通道之间的绝对差值，并与阈值 25 比较，生成三个布尔型掩膜。</li>
            <li><code>colored_mask = (diff_bg | diff_br | diff_gr)</code>: 将三个掩膜进行逻辑或运算，得到彩色区域的掩膜 <code>colored_mask</code>。</li>
            <li><code>src_bgr[colored_mask] = [0, 255, 0]</code>: 将原始 BGR 图像 <code>src_bgr</code> 中，由 <code>colored_mask</code> 标记为 True 的区域设置为绿色 <code>[0, 255, 0]</code> (BGR 颜色空间)。</li>
            <li><code>cv2.imwrite(output_path, src_bgr)</code>: 将修改后的绿色叠加图像保存到 <code>output_path</code>。</li>
            <li><code>return src_bgr</code>: 函数返回生成的绿色叠加图像 (BGR 格式)。</li>
          </ul>
        </p>
  
      <section id="section6-6">
        <h3>6.6. <code>create_black_bg_with_circles</code> 函数</h3>
        <p>
          定义函数 <code>create_black_bg_with_circles(src_path, plaque_data)</code>，用于创建黑底圆圈图。函数接收原始图像路径 <code>src_path</code> 和斑块数据 <code>plaque_data</code> 作为输入。函数在黑色背景上，根据 <code>plaque_data</code> 中提供的斑块信息，绘制绿色圆圈来表示斑块的位置和大小。函数返回生成的黑底圆圈图 (BGR 格式)。
        </p>
        <pre><code class="language-python">
  def create_black_bg_with_circles(src_path, plaque_data):
      src_gray = cv2.imread(src_path, cv2.IMREAD_GRAYSCALE)
      h, w = src_gray.shape[:2]
      black_bgr = np.zeros((h, w, 3), dtype=np.uint8)
      for (count, mean_row, mean_col) in plaque_data:
          c_x = int(round(mean_col))
          c_y = int(round(mean_row))
          radius = max(1, int(np.sqrt(count)))
          cv2.circle(black_bgr, (c_x, c_y), radius, (0, 255, 0), -1)
      return black_bgr
        </code></pre>
        <p>
          **代码详解:**
          <ul>
            <li><code>src_gray = cv2.imread(src_path, cv2.IMREAD_GRAYSCALE)</code>: 以灰度模式读取原始图像，仅用于获取图像的尺寸。</li>
            <li><code>h, w = src_gray.shape[:2]</code>: 获取原始灰度图像的高度 <code>h</code> 和宽度 <code>w</code>。</li>
            <li><code>black_bgr = np.zeros((h, w, 3), dtype=np.uint8)</code>: 创建一个黑色背景图像 <code>black_bgr</code>，尺寸与原始图像相同，通道数为 3 (BGR)，数据类型为 <code>np.uint8</code>。<code>np.zeros</code> 初始化所有像素值为 0 (黑色)。</li>
            <li><code>for (count, mean_row, mean_col) in plaque_data:</code>: 遍历斑块数据列表 <code>plaque_data</code>。每个元素是一个元组 <code>(count, mean_row, mean_col)</code>，分别代表斑块面积、质心行坐标和质心列坐标。</li>
            <li><code>c_x = int(round(mean_col))</code>, <code>c_y = int(round(mean_row))</code>: 将质心列坐标 <code>mean_col</code> 和行坐标 <code>mean_row</code> 四舍五入并转换为整数，得到圆心坐标 <code>(c_x, c_y)</code>。</li>
            <li><code>radius = max(1, int(np.sqrt(count)))</code>: 计算圆圈的半径。半径大小与斑块面积 <code>count</code> 的平方根成正比。使用 <code>max(1, ...)</code> 确保半径至少为 1 像素，避免半径为 0 的情况。</li>
            <li><code>cv2.circle(black_bgr, (c_x, c_y), radius, (0, 255, 0), -1)</code>: 在黑色背景图像 <code>black_bgr</code> 上绘制绿色圆圈。
              <ul>
                <li><code>(c_x, c_y)</code>: 圆心坐标。</li>
                <li><code>radius</code>: 圆圈半径。</li>
                <li><code>(0, 255, 0)</code>: 圆圈颜色，绿色 (BGR)。</li>
                <li><code>-1</code>: 线条粗细。<code>-1</code> 表示填充圆圈。</li>
              </ul>
            </li>
            <li><code>return black_bgr</code>: 函数返回生成的黑底圆圈图 (BGR 格式)。</li>
          </ul>
        </p>
  
      <section id="section6-7">
        <h3>6.7. <code>create_3panel_comparison</code> 函数</h3>
        <p>
          定义函数 <code>create_3panel_comparison(mouse_key, src_path, green_overlay_bgr, black_bg_bgr, output_folder)</code>，用于创建三联对比图。函数接收鼠标键 <code>mouse_key</code>, 原始图像路径 <code>src_path</code>, 绿色叠加图 <code>green_overlay_bgr</code>, 黑底圆圈图 <code>black_bg_bgr</code> 和输出文件夹 <code>output_folder</code> 作为输入。函数将原始图像、绿色叠加图和黑底圆圈图水平排列成三联图，并保存到 <code>output_folder</code>。
        </p>
        <pre><code class="language-python">
  def create_3panel_comparison(mouse_key, src_path, green_overlay_bgr, black_bg_bgr, output_folder):
      src_gray = cv2.imread(src_path, cv2.IMREAD_GRAYSCALE)
      if src_gray is None:
          raise IOError(f"无法加载原始图像: {src_path}")
      src_rgb = cv2.cvtColor(src_gray, cv2.COLOR_GRAY2RGB)
      overlay_rgb = cv2.cvtColor(green_overlay_bgr, cv2.COLOR_BGR2RGB)
      black_bg_rgb = cv2.cvtColor(black_bg_bgr, cv2.COLOR_BGR2RGB)
      plt.figure(figsize=(15, 5))
      plt.subplot(1, 3, 1)
      plt.imshow(src_rgb)
      plt.title(f"Original: {mouse_key}")
      plt.axis("off")
      plt.subplot(1, 3, 2)
      plt.imshow(overlay_rgb)
      plt.title("Green Overlay")
      plt.axis("off")
      plt.subplot(1, 3, 3)
      plt.imshow(black_bg_rgb)
      plt.title("Black BG w/ Circles")
      plt.axis("off")
      plt.tight_layout()
      out_path = os.path.join(output_folder, f"{mouse_key}_comparison.png")
      plt.savefig(out_path, dpi=150)
      plt.show()
      print(f"[INFO] 对比图已保存到: {out_path}")
        </code></pre>
        <p>
          **代码详解:**
          <ul>
            <li><code>src_gray = cv2.imread(src_path, cv2.IMREAD_GRAYSCALE)</code>: 以灰度模式读取原始图像。</li>
            <li><code>if src_gray is None: raise IOError(...)</code>: 检查是否成功加载原始图像，如果失败，抛出 <code>IOError</code> 异常.</li>
            <li><code>src_rgb = cv2.cvtColor(src_gray, cv2.COLOR_GRAY2RGB)</code>: 将原始灰度图像转换为 RGB 彩色图像，以便使用 <code>matplotlib</code> 显示。</li>
            <li><code>overlay_rgb = cv2.cvtColor(green_overlay_bgr, cv2.COLOR_BGR2RGB)</code>, <code>black_bg_rgb = cv2.cvtColor(black_bg_bgr, cv2.COLOR_BGR2RGB)</code>: 将绿色叠加图和黑底圆圈图从 BGR 颜色空间转换为 RGB 颜色空间，以便使用 <code>matplotlib</code> 显示。</li>
            <li><code>plt.figure(figsize=(15, 5))</code>: 创建一个新的 Matplotlib 图形对象，并设置图形的尺寸为 15x5 英寸。</li>
            <li><code>plt.subplot(1, 3, 1)</code>, <code>plt.subplot(1, 3, 2)</code>, <code>plt.subplot(1, 3, 3)</code>: 创建三个子图，水平排列在一行。<code>(1, 3, i)</code> 表示创建一个 1 行 3 列的子图网格，并选择第 <code>i</code> 个子图作为当前操作的子图。</li>
            <li><code>plt.imshow(src_rgb)</code>, <code>plt.imshow(overlay_rgb)</code>, <code>plt.imshow(black_bg_rgb)</code>: 在每个子图中显示对应的图像。</li>
            <li><code>plt.title(f"Original: {mouse_key}")</code>, <code>plt.title("Green Overlay")</code>, <code>plt.title("Black BG w/ Circles")</code>: 设置每个子图的标题。</li>
            <li><code>plt.axis("off")</code>: 关闭每个子图的坐标轴显示。</li>
            <li><code>plt.tight_layout()</code>: 自动调整子图布局，避免子图之间重叠。</li>
            <li><code>out_path = os.path.join(output_folder, f"{mouse_key}_comparison.png")</code>: 构建输出图像的文件路径，文件名基于鼠标键，并以 "_comparison.png" 结尾。</li>
            <li><code>plt.savefig(out_path, dpi=150)</code>: 将三联对比图保存到 <code>out_path</code>，DPI (每英寸点数) 设置为 150。</li>
            <li><code>plt.show()</code>: 显示生成的图形 (在交互式环境中)。</li>
            <li><code>print(f"[INFO] 对比图已保存到: {out_path}")</code>: 打印信息告知用户对比图已保存的路径。</li>
          </ul>
        </p>
  
      <section id="section6-8">
        <h3>6.8. 加载斑块数据</h3>
        <p>
          调用 <code>load_plaque_data(CSV_PATH)</code> 函数，从之前定义的 CSV 文件路径 <code>CSV_PATH</code> 加载斑块数据，并将返回的斑块数据字典赋值给 <code>plaque_dict</code> 变量。
        </p>
        <pre><code class="language-python">
  plaque_dict = load_plaque_data(CSV_PATH)
        </code></pre>
  
      <section id="section6-9">
        <h3>6.9. 批量生成图像</h3>
        <p>
          遍历之前构建的完整映射字典 <code>allmap</code>。对于 <code>allmap</code> 中的每个键值对 (<code>mouse_key</code>, <code>paths</code>)，执行以下操作：
          <ul>
            <li>从 <code>paths</code> 字典中获取原始图像路径 <code>src_path</code> 和对齐图像路径 <code>align_path</code>。</li>
            <li>构建绿色叠加图的输出路径 <code>green_output_path</code>，保存在 <code>GREEN_FOLDER</code> 文件夹下，文件名基于 <code>mouse_key</code>，扩展名为 ".tif"。</li>
            <li>调用 <code>create_green_overlay(src_path, align_path, green_output_path)</code> 函数，生成绿色叠加图，并将结果赋值给 <code>green_overlay_bgr</code> 变量。如果生成过程中发生异常，捕获异常并打印错误信息，然后继续处理下一个图像。</li>
            <li>从 <code>plaque_dict</code> 字典中根据 <code>mouse_key</code> 获取对应的斑块数据 <code>plaque_data</code>。如果 <code>plaque_dict</code> 中不存在 <code>mouse_key</code>，则 <code>plaque_data</code> 为空列表 <code>[]</code>。</li>
            <li>调用 <code>create_black_bg_with_circles(src_path, plaque_data)</code> 函数，生成黑底圆圈图，并将结果赋值给 <code>black_bg_bgr</code> 变量。</li>
            <li>调用 <code>create_3panel_comparison(mouse_key, src_path, green_overlay_bgr, black_bg_bgr, COMPARE_FOLDER)</code> 函数，生成三联对比图，并保存到 <code>COMPARE_FOLDER</code> 文件夹下。</li>
          </ul>
        </p>
        <pre><code class="language-python">
  for mouse_key, paths in allmap.items():
      src_path = paths["src"]
      align_path = paths["align"]
      print(f"[INFO] 处理 {mouse_key}...")
      green_output_path = os.path.join(GREEN_FOLDER, f"{mouse_key}.tif")
      try:
          green_overlay_bgr = create_green_overlay(src_path, align_path, green_output_path)
      except Exception as e:
          print(f"[ERROR] 为 {mouse_key}创建绿色叠加图失败: {e}")
          continue
      plaque_data = plaque_dict.get(mouse_key, [])
      black_bg_bgr = create_black_bg_with_circles(src_path, plaque_data)
      create_3panel_comparison(
          mouse_key=mouse_key,
          src_path=src_path,
          green_overlay_bgr=green_overlay_bgr,
          black_bg_bgr=black_bg_bgr,
          output_folder=COMPARE_FOLDER
      )
        </code></pre>
      </section>
    </section>
  
    <footer>
      <p>© 2025 Code Review. All Rights Reserved.</p>
    </footer>
  
    <!-- 引入 PrismJS 进行代码高亮 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  </body>
  </html>
